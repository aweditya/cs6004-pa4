# CS6004 Assignment PA4: Transform Me if You Can
## Aditya Sriram (200070004), Shashank Balaji (200070043)
[###### Link to this repository](https://github.com/aweditya/cs6004-pa4/tree/main)

## Assignment Objective
1. Generate result for any analysis (past analyses or existing analysis in Soot). For example, null-check analysis to remove null-checks from a program.
1. Use the analysis result to transform the class files.
1. Quantify the performance impact by measuring the run time improvment as well as the change in counter(s) (example, number of calls to monomorphic call sites) to be added in the JVM interpreter's code.

OpenJ9 JVM will be used for running and measuring the improvements for the test cases.

## Our Solution
### Analysis and Transformation
- We implemented Soot's `ConstantPropagatorAndFolder` transformation using the Soot's existing `SimpleLocalDefs` analysis and using its results to do the constant propagation and folding.
- At each program point, the `SimpleLocalDefs` analysis computes the assignments to local variables that reach the program point without being redefined. Note that this is an intra-procedural analysis.
- To implement constant propagation and folding, we start with variables that are assigned to constants. Then we use the results of the `SimpleLocalDefs` analysis to propagate these constants and fold expressions which consist of constants.

### Benchmarking
- We added an array of 20 counters to the interpreter code (`runtime/vm/BytecodeInterpreter.hpp`) for each of the mutually exhaustive classes of binary/unary operations: `ADD`, `SUB`, `NEG`, `MUL`, `DIV`, `REM`, `EQ`, `NEQ`, `GT`, `GE`, `LT`, `LE`, `AND`, `OR`, `XOR`, `SHL`, `SHR`, `USHR` (unsigned bitwise shift right), `CMP`, `IIN` (add constant). These counters count the number of times these operations occur in the Java bytecode.
- Note that the above categorization is used by Soot, and multiple bytecodes can map to the same category. Here is the complete mapping:

| Category | Bytecodes |
| -------- | --------- |
| `add`| `iadd`, `dadd`, `fadd`, `ladd`|
| `neg`| `dneg`, `fneg`, `lneg`, `ineg`|
| `sub`| `dsub`, `fsub`, `lsub`, `isub`|
| `mul`| `fmul`, `imul`, `dmul`, `lmul`|
| `div`| `ddiv`, `fdiv`, `ldiv`, `idiv`|
| `rem`| `drem`, `frem`, `lrem`, `irem`|
| `eq`| `if_acmpeq`, `if_icmpeq`, `ifeq`, `ifnull`|
| `neq`| `if_acmpne`, `if_icmpne`, `ifne`, `ifnonnull`|
| `gt`| `if_icmpgt`, `ifgt`|
| `ge`| `if_icmpge`, `ifge`|
| `lt`| `if_icmplt`, `iflt`|
| `le`| `if_icmple`, `ifle`|
| `and`| `iand`, `land `|
| `or`| `ior`, `lor`|
| `xor`| `lxor`, `ixor`|
| `shl`| `lshl`, `ishl`|
| `shr`| `lshr`, `ishr`|
| `ushr`| `lushr`, `iushr`|
| `cmp`| `lcmp`|
| `cmpg`| `dcmpg`, `fcmpg`|
| `cmpl`| `dcmpl`, `fcmpl`|
| `iinc`| `iinc`|

- We print the stats of the counters at the end of the interpreter's `run` method.
- During our experimentation, we noticed that even though the printing of stats was supposed to happen only once, it was being printed multiple times. We conjecture that this happens because the interpreter's `run` method is being called multiple times in order to "warm up" the JVM.
- So as to overshadow the resulting non-zero initial values of the counters, we made our test case large (around 5500 lines).
- The test case file is randomly generated by the `test-gen.py` script.
- Finally, we run the VM on the test case and record the run time and the counter stats.

## Build Steps
1) Download our source code from the shared repository.
2) Follow the instructions given on Piazza to build the Docker OpenJ9 VM image. After mounting a local directory, the `java` executable will be available in `/src/openj9-openjdk-jdk8/build/linux-x86_64-normal-server-release/images/j2sdk-image/bin`.
3) If the above steps have been done correctly, you should see the following directory structure on navigating to the `src` folder.
```
src
├── code
├── openj9-openjdk-jdk8
└── sootclasses-trunk-jar-with-dependencies.jar
```
4) `src/code` contains
    1. `AnalysisTransformer.java` and `PA4.java` which contain the code for constant propagation and folding and add it to Soot's Jimple transformation pack.
    2. `test-gen.py` which was used to generate the testcase stored in `cpf/` and `nocpf/`.
    3. `run-vm.sh` which accepts either `cpf` or `nocpf`, corresponding to whether you want to build the testcase with or without the optimisation enabled. The generated class file is stored in the `cpf/` and `nocpf/` respectively.
    4. The `cpf/` and `nocpf/` folders also contain statistics obtained on running the Soot-generated classfile on the OpenJ9 VM.
    5. `analysis.py` is a utility that parses the logfile dumped during VM execution and reports the average number of times each bytecode was called.
    6. `cpf-timings.txt` includes timing information to evaluate the runtime performance of constant propagation on our local machine and OpenJ9.
5) In case you want to generate a new testcase, run the following:
```bash
python test-gen.py cpf/Test.java
cp cpf/Test.java nocpf
```
6) Generate the classfile using Soot with and without constant propagation and folding:
```bash
./run-vm.sh cpf
./run-vm.sh nocpf
```
7) Finally, run the classfile
```bash
export PATH=/src/openj9-openjdk-jdk8/build/linux-x86_64-normal-server-release/images/j2sdk-image/bin:$PATH

# With constant propagation (log stored in counters-cpf.txt)
cd cpf
java -Xint Test 1>/dev/null 2>counters-cpf.txt 

cd ..

# Without constant propagation (log stored in counters-nocpf.txt)
cd nocpf
java -Xint Test 1>/dev/null 2>counters-nocpf.txt 

```
8) The generated logs can be analysed using `analysis.py`.
```bash
# Report average number of bytecode invocations, with and without
python analysis.py cpf/counters-cpf.txt
python analysis.py cpf/counters-nocpf.txt
```

## Results
### Counters    
| Category   | With CPF           | Without CPF      |
| ---------- | ------------------ | ---------------- |
| JIMPLE_ADD:  | 2645535.8747795415| 2442901.78975265  |
| JIMPLE_SUB:  | 2292792.7566137565| 5590361.001766784 |
| JIMPLE_NEG:  | 0.001763668430335097| 0.0017667844522968198 |
| JIMPLE_MUL:  | 2.303350970017637 | 3301470.1802120144|
| JIMPLE_DIV:  | 0.01763668430335097| 0.0176678445229682|
| JIMPLE_REM:  | 1.4250440917107583| 1.4240282685512367|
| JIMPLE_EQ:   | 5555623.299823633 | 5565439.0         |
| JIMPLE_NEQ:  | 5732014.019400353 | 5742141.443462897 |
| JIMPLE_GT:   | 2557332.8007054674| 2561851.1236749114|
| JIMPLE_GE:   | 3351939.2204585536| 3357861.6501766783|
| JIMPLE_LT:   | 1234585.2927689594| 1236766.574204947 |
| JIMPLE_LE:   | 1851860.4373897708| 1855132.2915194347|
| JIMPLE_AND:  | 264555.4109347443 | 265022.8250883392|
| JIMPLE_OR:   | 2.0899470899470898| 2.088339222614841 |
| JIMPLE_XOR:  | 1.0476190476190477| 1.0494699646643109|
| JIMPLE_SHL:  | 19.51851851851852 | 19.579505300353357|
| JIMPLE_SHR:  | 88184.39329805996 | 88340.20141342757 |
| JIMPLE_USHR: | 1.1675485008818343| 1.1696113074204948|
| JIMPLE_CMP:  | 176367.76543209876| 176679.36925795054|
| JIMPLE_IINC: | 1323732.5396825396| 1326071.5636042403|

### Timings
The timings reported below are by averaging over 4 runs on the OpenJ9 VM. There is a clear runtime performance improvement due to constant propagation and folding.
* With CPF: 281.6012 seconds
* Without CPF: 977.3855 seconds

